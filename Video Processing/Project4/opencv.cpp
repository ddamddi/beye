#include <iostream>
#include <opencv2\opencv.hpp>
#include <opencv2\imgproc\imgproc.hpp>
#include <opencv2\video\video.hpp>
#include <opencv2\core\core.hpp>

#define resizeSize 3

using namespace cv;
using namespace std;

bool intersection(Point start, Point end, Point center);		// 교차로 판별
double distanceBetweenPoints(Point point1, Point point2);		// 두 점 사이 거리

int main() {
	//global variables
	Mat origin;		// 원본
	Mat resizeImage;	// 사이즈 조정
	Mat MOG2Image; //fg mask fg mask generated by MOG2 method
	Mat grayImage;
	Mat contrastImage;
	Mat blurImage;
	Mat mophologyImage;
	Mat thresholdImage;
	Mat ContourImg;

	Ptr< BackgroundSubtractor> pMOG2; //MOG2 Background subtractor

	pMOG2 = createBackgroundSubtractorMOG2(500, 16, true);

	char fileName[100] = "Test_normal2.mp4";
	VideoCapture stream1(fileName);

	Mat element = getStructuringElement(MORPH_RECT, Size(7, 7), Point(3, 3));
	Mat element2 = getStructuringElement(MORPH_ELLIPSE, Size(3, 3));
	Mat element3 = getStructuringElement(MORPH_RECT, Size(1, 1));

	int countCar = 0;

	//unconditional loop   
	while (true) {

		if (!(stream1.read(origin))) //get one frame form video   
			break;
		//cout << pos[0].getX() << " " << pos[0].getY() << pos[0].getWidth() << endl;
		//line(origin, Point(pos[0].getX(), pos[0].getY()), Point(pos[0].getWidth(), pos[0].getHeight()), Scalar(255, 0, 0), 2);

		// 이미지 size 조절
		resize(origin, resizeImage, Size(origin.size().width / resizeSize, origin.size().height / resizeSize));

		/////////////////////////////////////////////////////////////////
		//1단계 : 밝기 대조 조정
		contrastImage = resizeImage.clone();
		float alpha = 1;
		int beta = 50;
		for (int y = 0; y < contrastImage.rows; y++) {
			for (int x = 0; x < contrastImage.cols; x++) {
				for (int c = 0; c < 3; c++) {
					contrastImage.at<Vec3b>(y, x)[c] = saturate_cast<uchar>(alpha*(contrastImage.at<Vec3b>(y, x)[c]) + beta);
				}
			}
		}
		float alpha2 = 0.5;
		int beta2 = 1;
		for (int i = 0; i < 3; i++) {
			for (int y = 0; y < contrastImage.rows; y++) {
				for (int x = 0; x < contrastImage.cols; x++) {
					for (int c = 0; c < 3; c++) {
						contrastImage.at<Vec3b>(y, x)[c] = saturate_cast<uchar>(alpha2*(contrastImage.at<Vec3b>(y, x)[c]) + beta2);
					}
				}
			}
		}
		alpha2 = 2;
		for (int i = 0; i < 3; i++) {
			for (int y = 0; y < contrastImage.rows; y++) {
				for (int x = 0; x < contrastImage.cols; x++) {
					for (int c = 0; c < 3; c++) {
						contrastImage.at<Vec3b>(y, x)[c] = saturate_cast<uchar>(alpha2*(contrastImage.at<Vec3b>(y, x)[c]) + beta2);
					}
				}
			}
		}
		imshow("1. 밝기, 대조 조정", contrastImage);
		//rgb조정 함수
		/*
		Mat temp = resizeF.clone();
		for (int y = 0; y < temp.rows; y++) {
		Vec3b* pixel = temp.ptr<Vec3b>(y);
		for (int x = 0; x < temp.cols; x++) {
		if (pixel[x][0] > 150) {
		pixel[x][2] = 255;
		pixel[x][1] = 0;
		pixel[x][0] = 0;
		}
		else {
		pixel[x][2] = 0;
		pixel[x][1] = 0;
		pixel[x][0] = 0;
		}
		}
		}
		gray_Image = temp;
		//cvtColor(resizeF, gray_Image, CV_RGB2GRAY);
		threshold(gray_Image, gray_Image, 128, 255, THRESH_BINARY);
		dilate(gray_Image, gray_Image, element2, Point(-1, -1), 1);

		imshow("1. gray", gray_Image);

		*/

		/////////////////////////////////////////////////////////////////
		//2단계 : 블러 처리 -> 인식되는 범위를 늘려줌
		blur(contrastImage, blurImage, Size(4, 4));
		//medianBlur(resizeF, resizeF, 5);
		//GaussianBlur(resizeF, resizeF, Size(5, 5), 1.5);


		/////////////////////////////////////////////////////////////////
		//3단계 : MOG2 적용 -> 배경 제거
		pMOG2->apply(blurImage, MOG2Image);
		imshow("2. blur + MOG2", MOG2Image);


		/////////////////////////////////////////////////////////////////
		//4단계 : morphology -> 침식 팽창 변환 적용
		//morphologyEx(MOG2Image, MOG2Image, CV_MOP_ERODE, element);
		morphologyEx(MOG2Image, mophologyImage, CV_MOP_CLOSE, element);
		morphologyEx(mophologyImage, mophologyImage, CV_MOP_OPEN, element2);
		dilate(mophologyImage, mophologyImage, element2, Point(-1, -1), 2);
		imshow("3. morphology", mophologyImage);

		/////////////////////////////////////////////////////////////////
		//5단계 : 그림자 제거
		threshold(mophologyImage, thresholdImage, 128, 255, THRESH_BINARY);
		imshow("4. threshold", thresholdImage);

		//blob
		// Setup SimpleBlobDetector parameters.
		SimpleBlobDetector::Params params;

		// Change thresholds
		params.minThreshold = 10;
		params.maxThreshold = 300;

		// Filter by Area.
		params.filterByArea = true;
		params.minArea = 1500;

		// Filter by Circularity
		params.filterByCircularity = true;
		params.minCircularity = 0.1;

		// Filter by Convexity
		params.filterByConvexity = true;
		params.minConvexity = 0.87;

		// Filter by Inertia
		params.filterByInertia = true;
		params.minInertiaRatio = 0.01;


		// Storage for blobs
		vector<KeyPoint> keypoints;

		// Set up detector with params
		Ptr<SimpleBlobDetector> detector = SimpleBlobDetector::create(params);

		// Detect blobs
		detector->detect(blurImage, keypoints);
		Mat blobImage;
		drawKeypoints(blurImage, keypoints, blobImage, Scalar(0, 0, 255), DrawMatchesFlags::DRAW_RICH_KEYPOINTS);

		// Show blobs
		imshow("5 . keypoints", blobImage);


		/////////////////////////////////////////////////////////////////
		/*//6단계 : contour찾기 -> 윤곽선 찾아서 네모칸 생성
		ContourImg = thresholdImage.clone();
		vector< vector< Point> > contours;
		findContours(ContourImg,
			contours, // a vector of contours
			CV_RETR_EXTERNAL, // retrieve the external contours
			CV_CHAIN_APPROX_NONE); // all pixels of each contours

		vector< Rect > output;
		vector< vector< Point> >::iterator itc = contours.begin();
		/*while (itc != contours.end()) {
			//Create bounding rect of object
			Rect mr = boundingRect(Mat(*itc));
			rectangle(resizeImage, mr, CV_RGB(255, 0, 0));
			++itc;
			if (distanceBetweenPoints(Point(mr.x, mr.y), Point(mr.x + (mr.width / 2), mr.y + (mr.height / 2))) > 100) {		// 네모칸 크기가 100 이상이면
				circle(resizeImage, Point(mr.x + (mr.width / 2), mr.y + (mr.height / 2)), 2, Scalar(255, 0, 0), 2);			// 가운데 점 하나 찍고
				if (intersection(Point(pos[0].getX(), pos[0].getY()) / resizeSize, Point(pos[0].getWidth(), pos[0].getHeight()) / resizeSize, Point(mr.x + (mr.width / 2), mr.y + (mr.height / 2))))
					countCar++;					// 교차점 지나가는지 확인
			}
		}*/
		imshow("5. end", resizeImage);

		//cout << "현재까지 지나간 차 수 : " << countCar << endl;

		if (waitKey(30) >= 0)
			break;
	}
	return 0;
}

bool intersection(Point start, Point end, Point center) {
	Point line = (start + end) / 2;
	double num1 = 0.0, num2 = 0.0, num3 = 0.0;
	num1 = distanceBetweenPoints(start, center);
	num2 = distanceBetweenPoints(end, center);
	num3 = distanceBetweenPoints(line, center);

	cout << num1 << " " << num2 << " " << num3 << endl;

	return true;
}

double distanceBetweenPoints(Point point1, Point point2) {

	int intX = abs(point1.x - point2.x);
	int intY = abs(point1.y - point2.y);

	return(sqrt(pow(intX, 2) + pow(intY, 2)));
}